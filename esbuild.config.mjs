import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import fs from "fs";
import path from "path";
import { BuildLogger, formatBytes, formatDuration } from "./build-logger.mjs";

const banner =
`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === "production");
const logger = new BuildLogger("Build");
const cssLogger = new BuildLogger("CSS");

const cssDir = path.join(process.cwd(), "src", "css");
const indexCssPath = path.join(cssDir, "index.css");

// Auto-sync built artifacts after each build/rebuild.
// - Set `SYSTEMSCULPT_AUTO_SYNC_PATH` to a plugin directory to sync into a real vault.
// - Dev builds also sync into the e2e fixture vault so WDIO can pick up the plugin instantly.
const autoSyncTargets = (() => {
	const targets = [];
	const explicitTarget = String(process.env.SYSTEMSCULPT_AUTO_SYNC_PATH || "").trim();
	if (explicitTarget) targets.push(explicitTarget);
	if (!prod) {
		targets.push(path.join(process.cwd(), "testing", "e2e", "fixtures", "vault", ".obsidian", "plugins", "systemsculpt-ai"));
	}
	return targets;
})();

const ensureCssSourcesExist = () => {
	if (!fs.existsSync(indexCssPath)) {
		throw new Error(`CSS entry file missing at ${indexCssPath}`);
	}
};

const parseImports = (cssFile) => {
	const content = fs.readFileSync(cssFile, "utf8");
	const withoutComments = content.replace(/\/\*[\s\S]*?\*\//g, "");
	const regex = /@import\s+['"](.+)['"]/g;
	const imports = [];
	let match;
	while ((match = regex.exec(withoutComments)) !== null) {
		imports.push(match[1]);
	}
	return imports;
};

const resolveCssPath = (importPath, basePath) => path.join(path.dirname(basePath), importPath);

const buildCSS = () => {
	try {
		ensureCssSourcesExist();
		const startTime = Date.now();
		const imports = parseImports(indexCssPath);
		let combinedCSS = `/**\n * SystemSculpt CSS\n * Generated from src/css/ sources.\n * DO NOT EDIT DIRECTLY.\n */\n\n`;
		let processedCount = 0;
		const missingFiles = [];

		imports.forEach(importPath => {
			const resolvedPath = resolveCssPath(importPath, indexCssPath);
			if (fs.existsSync(resolvedPath)) {
				const content = fs.readFileSync(resolvedPath, "utf8");
				combinedCSS += `/* ${path.basename(importPath)} */\n${content}\n\n`;
				processedCount++;
			} else {
				missingFiles.push(importPath);
			}
		});

		fs.writeFileSync("styles.css", combinedCSS);
		const duration = Date.now() - startTime;
		cssLogger.success(`Built CSS (${processedCount} files, ${formatDuration(duration)})`);
		if (missingFiles.length > 0) {
			cssLogger.warn(`Missing imports: ${missingFiles.join(", ")}`);
		}
		return combinedCSS;
	} catch (error) {
		cssLogger.error("CSS build failed", error.message ?? error);
		fs.writeFileSync("styles.css", "/* CSS build failed */\n");
		return null;
	}
};

const watchCss = () => {
	if (!fs.existsSync(cssDir)) {
		return;
	}
	fs.watch(cssDir, { recursive: true }, (eventType, filename) => {
		if (filename && filename.endsWith(".css")) {
			cssLogger.info(`File changed: ${filename}`);
			buildCSS();
			syncArtifacts();
		}
	});
};

const buildOptions = {
	banner: {
		js: banner,
	},
	entryPoints: ["src/main.ts"],
	bundle: true,
	alias: {
		"onnxruntime-node": "onnxruntime-web",
	},
	define: {
		// Provide a stable import.meta.url so libraries using fileURLToPath don't explode in browser-ish environments.
		"import.meta.url": '"file:///systemsculpt-plugin/main.js"',
	},
	external: [
		"obsidian",
		"electron",
		"@codemirror/autocomplete",
		"@codemirror/collab",
		"@codemirror/commands",
		"@codemirror/language",
		"@codemirror/lint",
		"@codemirror/search",
		"@codemirror/state",
		"@codemirror/view",
		"@lezer/common",
		"@lezer/highlight",
		"@lezer/lr",
		...builtins
	],
	format: "cjs",
	target: "es2018",
	logLevel: "error",
	sourcemap: prod ? false : "inline",
	// Keep side-effectful modules like @xenova/transformers intact; tree-shaking can strip
	// task registrations (e.g., feature-extraction) and break the local embeddings pipeline.
	treeShaking: false,
	outfile: "main.js",
	loader: {
		".wasm": "file",
	},
	plugins: [
		{
			name: "build-reporter",
			setup(build) {
				build.onEnd(result => {
					if (result.errors.length > 0) {
						logger.error(`Build failed with ${result.errors.length} errors`);
						result.errors.forEach(error => {
							logger.error(error.text, error.location);
						});
					}

					if (result.warnings.length > 0) {
						logger.warn(`Build completed with ${result.warnings.length} warnings`);
					}
				});
			}
		},
		{
			name: "finalize-assets",
			setup(build) {
				let buildStart = Date.now();
				build.onStart(() => {
					buildStart = Date.now();
				});
				build.onEnd(result => {
					if (result.errors.length > 0) {
						return;
					}
					finalizeBuild(buildStart, { watch: !prod && isWatching });
				});
			}
		}
	],
};

let isWatching = false;

const finalizeBuild = (startedAt, { watch } = {}) => {
	buildCSS();
	const stats = fs.statSync("main.js");
	const duration = Date.now() - startedAt;

	if (watch) {
		logger.info(`Rebuild updated assets (${formatDuration(duration)})`);
		logger.info(`Bundle size: ${formatBytes(stats.size)}`);
		syncArtifacts();
		return;
	}

	logger.divider();
	logger.success(`Build complete (${formatDuration(duration)})`);
	logger.info(`Bundle size: ${formatBytes(stats.size)}`);
	logger.divider();
	syncArtifacts();
};

const syncArtifacts = () => {
	if (!autoSyncTargets || autoSyncTargets.length === 0) return;
	const requiredFiles = ["manifest.json", "main.js", "styles.css"];
	const optionalFiles = ["README.md", "LICENSE", "versions.json"];

	for (const rawTarget of autoSyncTargets) {
		const target = rawTarget.startsWith("~")
			? path.join(process.env.HOME || "", rawTarget.slice(1))
			: rawTarget;

		try {
			fs.mkdirSync(target, { recursive: true });
			for (const file of requiredFiles.concat(optionalFiles)) {
				const src = path.join(process.cwd(), file);
				if (!fs.existsSync(src)) {
					if (requiredFiles.includes(file)) {
						throw new Error(`Required file missing: ${src}`);
					}
					continue;
				}
				const dest = path.join(target, path.basename(file));
				fs.copyFileSync(src, dest);
			}
			logger.info(`[Sync] Updated ${target}`);
		} catch (error) {
			logger.warn(`[Sync] Failed to update ${target}: ${error?.message || error}`);
		}
	}
};

const run = async () => {
	try {
		if (prod) {
			await esbuild.build(buildOptions);
			return;
		}

		const ctx = await esbuild.context(buildOptions);
		await ctx.rebuild();
		isWatching = true;
		await ctx.watch();
		watchCss();
		logger.info("Watching for changes...");
	} catch (error) {
		logger.error("Build failed", error);
		process.exit(1);
	}
};

run();
